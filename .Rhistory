scale_fill_gradient(low = "blue", high = "red") +
labs(title = "Predicted Bike Rentals", subtitle = "Temperature vs. Humidity Effects") +
theme_minimal()
# Arrange the plots side by side
combined_plot <- grid.arrange(density_plot, pdp_plot, ncol = 2)
# Optionally, display the combined plot if using an interactive R environment
print(combined_plot)
print(combined_plot)
pdp_plot
density_plot
# Plotting the Partial Dependency with overlaying density
ggplot(grid, aes(x = temp, y = hum, fill = predicted_cnt)) +
geom_tile() +  # Create the 2D plot with filled color based on predictions
geom_density_2d(data = data, aes(x = temp, y = hum), size = 0.3, color = "white") +  # Overlay density lines
scale_fill_gradientn(colors = terrain.colors(10)) +  # Use a gradient color scale
labs(title = "2D Partial Dependency Plot with Density Overlay",
subtitle = "Effect of Temperature and Humidity on Bike Rentals",
x = "Temperature (°C)", y = "Humidity (%)",
fill = "Predicted Number of Bikes Rented") +
theme_minimal()
library(ggplot2)
library(gridExtra)  # for arranging plots side by side
# Density Plot with stat_density_2d
density_plot <- ggplot(sampled_data, aes(x = temp, y = hum)) +
stat_density_2d(aes(fill = stat(density)), geom = "raster", contour = FALSE) +
scale_fill_viridis_c() +
labs(title = "Density Distribution of Temperature and Humidity") +
theme_minimal()
# Partial Dependency Plot
pdp_plot <- ggplot(grid, aes(x = temp, y = hum, fill = predicted_cnt)) +
geom_tile() +  # Ensure you have appropriate width and height if necessary
scale_fill_gradient(low = "blue", high = "red") +
labs(title = "Predicted Bike Rentals", subtitle = "Temperature vs. Humidity Effects") +
theme_minimal()
# Arrange the plots side by side
combined_plot <- grid.arrange(density_plot, pdp_plot, ncol = 2)
# Optionally, display the combined plot if using an interactive R environment
print(combined_plot)
# Density Plot with stat_density_2d
density_plot <- ggplot(sampled_data, aes(x = temp, y = hum)) +
stat_density_2d(aes(fill = stat(density)), geom = "raster", contour = FALSE) +
scale_fill_viridis_c() +
labs(title = "Density Distribution of Temperature and Humidity") +
theme_minimal()
# Partial Dependency Plot
pdp_plot <- ggplot(grid, aes(x = temp, y = hum, fill = predicted_cnt)) +
geom_tile() +  # Ensure you have appropriate width and height if necessary
scale_fill_gradient(low = "blue", high = "red") +
labs(title = "Predicted Bike Rentals", subtitle = "Temperature vs. Humidity Effects") +
theme_minimal()
density_plot
ggplot() +
geom_tile(data = grid, aes(x = temp, y = hum, fill = predicted_cnt)) +  # Create the 2D plot
geom_density_2d(data = data, aes(x = temp, y = hum), linewidth = 0.3, color = "white") +  # Overlay density lines
scale_fill_gradientn(colors = terrain.colors(10)) +  # Use a gradient color scale
labs(title = "2D Partial Dependency Plot with Density Overlay",
subtitle = "Effect of Temperature and Humidity on Bike Rentals",
x = "Temperature (°C)", y = "Humidity (%)",
fill = "Predicted Number of Bikes Rented") +
theme_minimal()
pdp_plot
pdp_plot
ggplot() +
geom_tile(data = grid, aes(x = temp, y = hum, fill = predicted_cnt)) +  # Create the 2D plot
geom_density_2d(data = data, aes(x = temp, y = hum), linewidth = 0.3, color = "white") +  # Overlay density lines
scale_fill_gradientn(colors = terrain.colors(10)) +  # Use a gradient color scale
labs(title = "2D Partial Dependency Plot with Density Overlay",
subtitle = "Effect of Temperature and Humidity on Bike Rentals",
x = "Temperature (°C)", y = "Humidity (%)",
fill = "Predicted Number of Bikes Rented") +
theme_minimal()
ggplot() +
geom_tile(data = grid, aes(x = temp, y = hum, fill = predicted_cnt)) +  # Create the 2D plot
geom_density_2d(data = data, aes(x = temp, y = hum), linewidth = 0.3, color = "white") +  # Overlay density lines
scale_fill_gradientn(colors = terrain.colors(10)) +  # Use a gradient color scale
labs(title = "2D Partial Dependency Plot with Density Overlay",
subtitle = "Effect of Temperature and Humidity on Bike Rentals",
x = "Temperature (°C)", y = "Humidity (%)",
fill = "Predicted Number of Bikes Rented") +
theme_minimal()
library(ggplot2)
library(randomForest)
# Assuming your model and data are already prepared
# Generate the prediction grid
temp_seq <- seq(min(data$temp), max(data$temp), length.out = 100)
hum_seq <- seq(min(data$hum), max(data$hum), length.out = 100)
grid <- expand.grid(temp = temp_seq, hum = hum_seq)
# Predict using the trained model
grid$predicted_cnt <- predict(model, newdata = grid)
# Create the plot
ggplot(grid, aes(x = temp, y = hum, fill = predicted_cnt)) +
geom_tile() +  # Use geom_tile for the heatmap style plot
geom_density_2d(data = data, aes(x = temp, y = hum), stat = "density2d", contour = TRUE, color = "white") +
scale_fill_gradientn(colors = terrain.colors(10), name = "Predicted Number of Bikes Rented") +
labs(title = "2D Partial Dependency Plot with Density Overlay",
subtitle = "Effect of Temperature and Humidity on Bike Rentals",
x = "Temperature (°C)", y = "Humidity (%)") +
theme_minimal()
library(ggplot2)
library(randomForest)
# Assuming 'data' is the original dataset and 'model' is your pre-trained model.
# First, prepare your prediction grid based on unique combinations in the data or defined ranges:
temp_seq <- seq(min(data$temp), max(data$temp), length.out = 50)
hum_seq <- seq(min(data$hum), max(data$hum), length.out = 50)
grid <- expand.grid(temp = temp_seq, hum = hum_seq)
# Predict bike rentals for each combination of temp and hum
grid$predicted_cnt <- predict(model, newdata = grid)
# Now create the plot
ggplot() +
geom_tile(data = grid, aes(x = temp, y = hum, fill = predicted_cnt)) + # Display the prediction results
scale_fill_gradientn(colors = terrain.colors(10), name = "Predicted Bike Rentals") +
geom_density_2d(data = data, aes(x = temp, y = hum), color = "white", size = 0.7) + # Overlay density contours
labs(title = "2D Partial Dependency Plot with Density Overlay",
subtitle = "Effect of Temperature and Humidity on Bike Rentals",
x = "Temperature (°C)", y = "Humidity (%)") +
theme_minimal()
p = ggplot() +
geom_tile(data = grid, aes(x = temp, y = hum, fill = predicted_cnt)) +  # Create the 2D plot
geom_density_2d(data = data, aes(x = temp, y = hum), linewidth = 0.3, color = "white") +  # Overlay density lines
scale_fill_gradientn(colors = terrain.colors(10)) +  # Use a gradient color scale
labs(title = "2D Partial Dependency Plot with Density Overlay",
subtitle = "Effect of Temperature and Humidity on Bike Rentals",
x = "Temperature (°C)", y = "Humidity (%)",
fill = "Predicted Number of Bikes Rented") +
theme_minimal()
p
p = ggplot() +
geom_tile(data = grid, aes(x = temp, y = hum, fill = predicted_cnt)) +  # Create the 2D plot
geom_density_2d(data = data, aes(x = temp, y = hum), linewidth = 0.3, color = "white") +  # Overlay density lines
scale_fill_gradientn(colors = terrain.colors(10)) +  # Use a gradient color scale
labs(title = "2D Partial Dependency Plot with Density Overlay",
subtitle = "Effect of Temperature and Humidity on Bike Rentals",
x = "Temperature (°C)", y = "Humidity (%)",
fill = "Predicted Number of Bikes Rented") +
theme_minimal()
p
p
library(ggplot2)
library(randomForest)
library(dplyr)
set.seed(123)
sampled_data <- sample_n(model_data, size = 500)
model <- randomForest(cnt ~ temp + hum, data = sampled_data)
# Create a grid of values for temperature and humidity
temp_seq <- seq(from = min(sampled_data$temp), to = max(sampled_data$temp), length.out = 50)
hum_seq <- seq(from = min(sampled_data$hum), to = max(sampled_data$hum), length.out = 50)
grid <- expand.grid(temp = temp_seq, hum = hum_seq)
grid$predicted_cnt = predict(model, newdata = grid)
p = ggplot() +
geom_tile(data = grid, aes(x = temp, y = hum, fill = predicted_cnt)) +  # Create the 2D plot
geom_density_2d(data = data, aes(x = temp, y = hum), linewidth = 0.3, color = "white") +  # Overlay density lines
scale_fill_gradientn(colors = terrain.colors(10)) +  # Use a gradient color scale
labs(title = "2D Partial Dependency Plot with Density Overlay",
subtitle = "Effect of Temperature and Humidity on Bike Rentals",
x = "Temperature (°C)", y = "Humidity (%)",
fill = "Predicted Number of Bikes Rented") +
theme_minimal()
p
library(ggplot2)
library(randomForest)
library(dplyr)
set.seed(123)
sampled_data <- sample_n(model_data)
library(ggplot2)
library(randomForest)
library(dplyr)
set.seed(123)
sampled_data <- sample_n(model_data, size = 20000)
library(ggplot2)
library(randomForest)
library(dplyr)
set.seed(123)
sampled_data <- sample_n(model_data, size = 2000)
model <- randomForest(cnt ~ temp + hum, data = sampled_data)
# Create a grid of values for temperature and humidity
temp_seq <- seq(from = min(sampled_data$temp), to = max(sampled_data$temp), length.out = 50)
hum_seq <- seq(from = min(sampled_data$hum), to = max(sampled_data$hum), length.out = 50)
grid <- expand.grid(temp = temp_seq, hum = hum_seq)
grid$predicted_cnt = predict(model, newdata = grid)
p = ggplot() +
geom_tile(data = grid, aes(x = temp, y = hum, fill = predicted_cnt)) +  # Create the 2D plot
geom_density_2d(data = data, aes(x = temp, y = hum), linewidth = 0.3, color = "white") +  # Overlay density lines
scale_fill_gradientn(colors = terrain.colors(10)) +  # Use a gradient color scale
labs(title = "2D Partial Dependency Plot with Density Overlay",
subtitle = "Effect of Temperature and Humidity on Bike Rentals",
x = "Temperature (°C)", y = "Humidity (%)",
fill = "Predicted Number of Bikes Rented") +
theme_minimal()
p
p = ggplot() +
geom_tile(data = grid, aes(x = temp, y = hum, fill = predicted_cnt)) +  # Create the 2D plot
geom_density_2d(data = data, aes(x = temp, y = hum), linewidth = 0.3, color = "white") +  # Overlay density lines
scale_fill_gradientn(colors = c("blue", "green", "yellow", "red")) +  # Custom color gradient
labs(title = "2D Partial Dependency Plot with Density Overlay",
subtitle = "Effect of Temperature and Humidity on Bike Rentals",
x = "Temperature (°C)", y = "Humidity (%)",
fill = "Predicted Number of Bikes Rented") +
theme_minimal()
p
p = ggplot() +
geom_tile(data = grid, aes(x = temp, y = hum, fill = predicted_cnt)) +  # Create the 2D plot
geom_density_2d(data = data, aes(x = temp, y = hum), linewidth = 0.3, color = "white") +  # Overlay density lines
scale_fill_gradientn(colors = c("#A62957", "#D966A5", "#2180A6", "#3BC9D9")) +  # Custom color gradient
labs(title = "2D Partial Dependency Plot with Density Overlay",
subtitle = "Effect of Temperature and Humidity on Bike Rentals",
x = "Temperature (°C)", y = "Humidity (%)",
fill = "Predicted Number of Bikes Rented") +
theme_minimal()
p
p
p = ggplot() +
geom_tile(data = grid, aes(x = temp, y = hum, fill = predicted_cnt)) +  # Create the 2D plot
geom_density_2d(data = data, aes(x = temp, y = hum), linewidth = 0.3, color = "white") +  # Overlay density lines
scale_fill_gradientn(colors = c("#A62957", "#2180A6", "#D966A5", "#3BC9D9")) +  # Custom color gradient
labs(title = "2D Partial Dependency Plot with Density Overlay",
subtitle = "Effect of Temperature and Humidity on Bike Rentals",
x = "Temperature (°C)", y = "Humidity (%)",
fill = "Predicted Number of Bikes Rented") +
theme_minimal()
p
p
p = ggplot() +
geom_tile(data = grid, aes(x = temp, y = hum, fill = predicted_cnt)) +  # Create the 2D plot
geom_density_2d(data = data, aes(x = temp, y = hum), linewidth = 0.3, color = "white") +  # Overlay density lines
scale_fill_gradientn(colors = c("#A62957", "#D966A5", "#2180A6", "#3BC9D9")) +  # Custom color gradient
labs(title = "2D Partial Dependency Plot with Density Overlay",
subtitle = "Effect of Temperature and Humidity on Bike Rentals",
x = "Temperature (°C)", y = "Humidity (%)",
fill = "Predicted Number of Bikes Rented") +
theme_minimal()
p
p
p
# Load necessary libraries
library(randomForest)
library(ggplot2)
library(dplyr)
# Load the data
kc_house_data <- read.csv("kc_house_data.csv")
# Load the data
kc_house_data <- read.csv("Datos/kc_house_data.csv")
# View the structure of the data
str(kc_house_data)
# Set seed for reproducibility
set.seed(123)
# Sample the data
sampled_data <- kc_house_data %>% sample_n(1000)  # Adjust the sample size as needed
# Train the Random Forest model
model <- randomForest(price ~ bedrooms + bathrooms + sqft_living + sqft_lot + floors + yr_built,
data = sampled_data)
# Create a function to generate partial dependency data
generate_pdp_data <- function(model, data, feature, grid_points = 50) {
grid <- data.frame(feature = seq(min(data[[feature]]), max(data[[feature]]), length.out = grid_points))
other_features <- setdiff(names(data), feature)
fixed_values <- apply(data[other_features], 2, median)
expanded_grid <- merge(grid, data.frame(fixed_values), all = TRUE)
expanded_grid$prediction <- predict(model, expanded_grid)
return(expanded_grid)
}
# Generate PDP data for each feature
features <- c("bedrooms", "bathrooms", "sqft_living", "sqft_lot", "floors", "yr_built")
pdp_data <- lapply(features, generate_pdp_data, model = model, data = sampled_data)
# Train the Random Forest model
model <- randomForest(price ~ bedrooms + bathrooms + sqft_living + sqft_lot + floors + yr_built,
data = sampled_data)
# Set seed for reproducibility
set.seed(123)
# Sample the data
sampled_data <- kc_house_data %>% sample_n(1000)  # Adjust the sample size as needed
View(rf_model)
View(sampled_data)
# Load necessary libraries
library(randomForest)
library(ggplot2)
library(dplyr)
# Load the data
kc_house_data <- read.csv("Datos/kc_house_data.csv")
# View the structure of the data
str(kc_house_data)
# Train the Random Forest model
# Train the Random Forest model
model <- randomForest(price ~ bedrooms + bathrooms + sqft_living + sqft_lot + floors + yr_built,
data = sampled_data)
# View the model summary
print(model)
# Create a function to generate partial dependency data
generate_pdp_data <- function(model, data, feature, grid_points = 50) {
feature_values <- seq(min(data[[feature]]), max(data[[feature]]), length.out = grid_points)
other_features <- setdiff(names(data), c(feature, "price"))
grid <- expand.grid(feature_values, replicate(length(other_features), mean(data[[other_features]])))
colnames(grid) <- c(feature, other_features)
grid$predicted_price <- predict(model, grid)
return(grid)
}
# Generate PDP data for each feature
features <- c("bedrooms", "bathrooms", "sqft_living", "sqft_lot", "floors", "yr_built")
pdp_data <- lapply(features, function(f) generate_pdp_data(model, sampled_data, f))
# Function to generate partial dependency data for a single feature
generate_pdp_data <- function(model, data, feature, grid_points = 50) {
grid <- data.frame(feature = seq(min(data[[feature]]), max(data[[feature]]), length.out = grid_points))
other_features <- setdiff(names(data), c(feature, "price"))
for (f in other_features) {
grid[[f]] <- mean(data[[f]], na.rm = TRUE)
}
grid$predicted_price <- predict(model, grid)
return(grid)
}
# Generate PDP data for each feature
features <- c("bedrooms", "bathrooms", "sqft_living", "sqft_lot", "floors", "yr_built")
pdp_data <- lapply(features, function(f) {
pdp <- generate_pdp_data(model, sampled_data, f)
colnames(pdp)[1] <- f
return(pdp)
})
# Function to generate partial dependency data for a single feature
generate_pdp_data <- function(model, data, feature, grid_points = 50) {
grid <- data.frame(feature = seq(min(data[[feature]]), max(data[[feature]]), length.out = grid_points))
colnames(grid) <- feature
other_features <- setdiff(names(data), c(feature, "price"))
for (f in other_features) {
grid[[f]] <- mean(data[[f]], na.rm = TRUE)
}
grid$predicted_price <- predict(model, newdata = grid)
return(grid)
}
# Generate PDP data for each feature
features <- c("bedrooms", "bathrooms", "sqft_living", "sqft_lot", "floors", "yr_built")
pdp_data <- lapply(features, function(f) {
pdp <- generate_pdp_data(model, sampled_data, f)
colnames(pdp)[1] <- f
return(pdp)
})
# Function to plot the partial dependency for a single feature
plot_pdp <- function(pdp_data, feature) {
ggplot(pdp_data, aes_string(x = feature, y = "predicted_price")) +
geom_line() +
labs(title = paste("Partial Dependency Plot:", feature),
x = feature, y = "Predicted Price") +
theme_minimal()
}
# Create and display PDP plots
pdp_plots <- lapply(1:length(features), function(i) plot_pdp(pdp_data[[i]], features[i]))
# Print PDP plots
library(gridExtra)
do.call(grid.arrange, c(pdp_plots, ncol = 2))
do.call(grid.arrange, c(pdp_plots, ncol = 2))
# Function to generate partial dependency data for a single feature
generate_pdp_data <- function(model, data, feature, grid_points = 50) {
grid <- data.frame(feature = seq(min(data[[feature]]), max(data[[feature]]), length.out = grid_points))
colnames(grid) <- feature
other_features <- setdiff(names(data), c(feature, "price"))
for (f in other_features) {
grid[[f]] <- mean(data[[f]], na.rm = TRUE)
}
grid$predicted_price <- predict(model, newdata = grid)
return(grid)
}
# Generate PDP data for each feature
features <- c("bedrooms", "bathrooms", "sqft_living", "sqft_lot", "floors", "yr_built")
pdp_data <- lapply(features, function(f) {
pdp <- generate_pdp_data(model, sampled_data, f)
colnames(pdp)[1] <- f
return(pdp)
})
# Function to plot the partial dependency for a single feature
plot_pdp <- function(pdp_data, feature, color = 'blue') {
ggplot(pdp_data, aes_string(x = feature, y = "predicted_price")) +
geom_line() +
labs(title = paste("Partial Dependency Plot:", feature),
x = feature, y = "Predicted Price") +
theme_minimal()
}
# Create and display PDP plots
pdp_plots <- lapply(1:length(features), function(i) plot_pdp(pdp_data[[i]], features[i]))
# Print PDP plots
library(gridExtra)
do.call(grid.arrange, c(pdp_plots, ncol = 2))
do.call(grid.arrange, c(pdp_plots, ncol = 2))
# Function to generate partial dependency data for a single feature
generate_pdp_data <- function(model, data, feature, grid_points = 50) {
grid <- data.frame(feature = seq(min(data[[feature]]), max(data[[feature]]), length.out = grid_points))
colnames(grid) <- feature
other_features <- setdiff(names(data), c(feature, "price"))
for (f in other_features) {
grid[[f]] <- mean(data[[f]], na.rm = TRUE)
}
grid$predicted_price <- predict(model, newdata = grid)
return(grid)
}
# Generate PDP data for each feature
features <- c("bedrooms", "bathrooms", "sqft_living", "sqft_lot", "floors", "yr_built")
pdp_data <- lapply(features, function(f) {
pdp <- generate_pdp_data(model, sampled_data, f)
colnames(pdp)[1] <- f
return(pdp)
})
# Function to plot the partial dependency for a single feature with color
plot_pdp <- function(pdp_data, feature, color = "blue") {
ggplot(pdp_data, aes_string(x = feature, y = "predicted_price")) +
geom_line(color = color) +
labs(title = paste("Partial Dependency Plot:", feature),
x = feature, y = "Predicted Price") +
theme_minimal()
}
# Create and display PDP plots with color
pdp_plots <- lapply(1:length(features), function(i) plot_pdp(pdp_data[[i]], features[i], color = "blue"))
# Print PDP plots
library(gridExtra)
do.call(grid.arrange, c(pdp_plots, ncol = 2))
library(gridExtra)
do.call(grid.arrange, c(pdp_plots, ncol = 2))
# Function to generate partial dependency data for a single feature
generate_pdp_data <- function(model, data, feature, grid_points = 50) {
grid <- data.frame(feature = seq(min(data[[feature]]), max(data[[feature]]), length.out = grid_points))
colnames(grid) <- feature
other_features <- setdiff(names(data), c(feature, "price"))
for (f in other_features) {
grid[[f]] <- mean(data[[f]], na.rm = TRUE)
}
grid$predicted_price <- predict(model, newdata = grid)
return(grid)
}
# Generate PDP data for each feature
features <- c("bedrooms", "bathrooms", "sqft_living", "sqft_lot", "floors", "yr_built")
pdp_data <- lapply(features, function(f) {
pdp <- generate_pdp_data(model, sampled_data, f)
colnames(pdp)[1] <- f
return(pdp)
})
# List of colors for the plots
colors <- c("red", "blue", "green", "purple", "orange", "brown")
# Function to plot the partial dependency for a single feature with different colors
plot_pdp <- function(pdp_data, feature, color) {
ggplot(pdp_data, aes_string(x = feature, y = "predicted_price")) +
geom_line(color = color) +
labs(title = paste("Partial Dependency Plot:", feature),
x = feature, y = "Predicted Price") +
theme_minimal()
}
# Create and display PDP plots with different colors
pdp_plots <- lapply(1:length(features), function(i) plot_pdp(pdp_data[[i]], features[i], color = colors[i]))
# Print PDP plots
library(gridExtra)
do.call(grid.arrange, c(pdp_plots, ncol = 2))
do.call(grid.arrange, c(pdp_plots, ncol = 2))
# Function to generate partial dependency data for a single feature
generate_pdp_data <- function(model, data, feature, grid_points = 50) {
grid <- data.frame(feature = seq(min(data[[feature]]), max(data[[feature]]), length.out = grid_points))
colnames(grid) <- feature
other_features <- setdiff(names(data), c(feature, "price"))
for (f in other_features) {
grid[[f]] <- mean(data[[f]], na.rm = TRUE)
}
grid$predicted_price <- predict(model, newdata = grid)
return(grid)
}
# Generate PDP data for each feature
features <- c("bedrooms", "bathrooms", "sqft_living", "sqft_lot", "floors", "yr_built")
pdp_data <- lapply(features, function(f) {
pdp <- generate_pdp_data(model, sampled_data, f)
colnames(pdp)[1] <- f
return(pdp)
})
# Function to plot the partial dependency for a single feature with color
plot_pdp <- function(pdp_data, feature, color = "#D966A5") {
ggplot(pdp_data, aes_string(x = feature, y = "predicted_price")) +
geom_line(color = color) +
labs(title = paste("Partial Dependency Plot:", feature),
x = feature, y = "Predicted Price") +
theme_minimal()
}
# Create and display PDP plots with color
pdp_plots <- lapply(1:length(features), function(i) plot_pdp(pdp_data[[i]], features[i], color = "#D966A5"))
# Print PDP plots
library(gridExtra)
do.call(grid.arrange, c(pdp_plots, ncol = 2))
# Function to generate partial dependency data for a single feature
generate_pdp_data <- function(model, data, feature, grid_points = 50) {
grid <- data.frame(feature = seq(min(data[[feature]]), max(data[[feature]]), length.out = grid_points))
colnames(grid) <- feature
other_features <- setdiff(names(data), c(feature, "price"))
for (f in other_features) {
grid[[f]] <- mean(data[[f]], na.rm = TRUE)
}
grid$predicted_price <- predict(model, newdata = grid)
return(grid)
}
# Generate PDP data for each feature
features <- c("bedrooms", "bathrooms", "sqft_living", "sqft_lot", "floors", "yr_built")
pdp_data <- lapply(features, function(f) {
pdp <- generate_pdp_data(model, sampled_data, f)
colnames(pdp)[1] <- f
return(pdp)
})
# Function to plot the partial dependency for a single feature with color
plot_pdp <- function(pdp_data, feature, color = "#D966A5") {
ggplot(pdp_data, aes_string(x = feature, y = "predicted_price")) +
geom_line(color = color) +
labs(title = paste("Partial Dependency Plot:", feature),
x = feature, y = "Predicted Price") +
theme_minimal()
}
# Create and display PDP plots with color
pdp_plots <- lapply(1:length(features), function(i) plot_pdp(pdp_data[[i]], features[i], color = "#D966A5"))
# Print PDP plots
library(gridExtra)
a = do.call(grid.arrange, c(pdp_plots, ncol = 2))
a
a
a
pdp_plots
a = do.call(grid.arrange, c(pdp_plots, ncol = 2))
